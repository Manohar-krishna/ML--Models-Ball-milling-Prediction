# -*- coding: utf-8 -*-
"""CV2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J6J2SWR0RhU8mLwLFUHtJmp3P9WDi9HQ
"""

import os
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

def calculate_sphericity(image_path):
    # Load image in grayscale
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    plt.figure(figsize=(6,6))
    plt.imshow(image, cmap='gray')
    plt.title("Original Image")
    plt.axis('off')
    plt.show()

    # Apply Gaussian blur to reduce noise
    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    plt.figure(figsize=(6,6))
    plt.imshow(blurred, cmap='gray')
    plt.title("Blurred Image")
    plt.axis('off')
    plt.show()

    # Apply Otsu's thresholding
    _, thresh = cv2.threshold(blurred, 40, 255, cv2.THRESH_BINARY_INV)
    _, thresh = cv2.threshold(thresh, 10, 255, cv2.THRESH_BINARY_INV)
    plt.figure(figsize=(6,6))
    plt.imshow(thresh, cmap='gray')
    plt.title("Thresholded Image (THRESH_BINARY_INV)")
    plt.axis('off')
    plt.show()

    # Morphological Closing
    kernel = np.ones((3, 3), np.uint8)
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=5)
    plt.figure(figsize=(6,6))
    plt.imshow(closed, cmap='gray')
    plt.title("Closed Image")
    plt.axis('off')
    plt.show()

    # Canny Edge Detection
    edges = cv2.Canny(closed, 100, 200)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    plt.figure(figsize=(6,6))
    plt.imshow(edges, cmap='gray')
    plt.title("Edge Detection")
    plt.axis('off')
    plt.show()

    # Draw Contours
    contour_img = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)
    cv2.drawContours(contour_img, contours, -1, (0, 255, 0), 2)
    plt.figure(figsize=(8, 8))
    plt.imshow(contour_img)
    plt.title("Contours")
    plt.axis('off')
    plt.show()

    sphericity_scores = []
    size_weights = []

    for contour in contours:
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if area < 50 or perimeter == 0:
            continue

        circularity = (np.sqrt(area) * np.sqrt(np.pi)) / (perimeter / 2)
        print('circularity:', circularity)
        sphericity_score = min(100, max(0, circularity * 100))

        sphericity_scores.append(sphericity_score)
        size_weights.append(area)

    if sphericity_scores:
        weighted_sphericity = np.average(sphericity_scores, weights=size_weights)
        median_sphericity = np.median(sphericity_scores)
        maximum_sphericity = np.max(sphericity_scores)
        mode_sphericity = stats.mode(sphericity_scores, keepdims=True).mode[0]
    else:
        weighted_sphericity = 0
        median_sphericity = 0
        maximum_sphericity = 0
        mode_sphericity = 0

    print("Average:", weighted_sphericity)
    print("Median:", median_sphericity)
    print("Maximum:", maximum_sphericity)
    print("Mode:", mode_sphericity)

    return weighted_sphericity

# Folder containing all microstructure data
root_folder = "/content/sample_data/data"  # Change this path as needed

# List to store results
results = []

# Iterate through each condition folder
for condition_folder in os.listdir(root_folder):
    condition_path = os.path.join(root_folder, condition_folder)
    if not os.path.isdir(condition_path):
        continue

    parts = condition_folder.split(",")
    if len(parts) < 2:
        continue

    ball_size = parts[0].strip()
    speed = parts[1].strip()

    for image_file in os.listdir(condition_path):
        if not (image_file.endswith(".png") or image_file.endswith(".jpg") or image_file.endswith(".tif")):
            continue

        time = image_file.replace(".png", "").replace(".jpg", "").replace(".tif", "").strip()
        image_path = os.path.join(condition_path, image_file)
        sphericity = calculate_sphericity(image_path)
        results.append([ball_size, speed, time, sphericity])

# Convert results to DataFrame and save
df = pd.DataFrame(results, columns=["Ball Size", "Speed", "Time", "Sphericity Score"])
df.to_csv("sphericity_results.csv", index=False)
print(df)

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import re

# Original data
data = {
    "Ball Size": ["10mm", "10mm", "10mm", "10mm", "10mm", "10mm", "5mm", "5mm", "5mm"],
    "Speed": ["600 RPM", "600 RPM", "600 RPM", "400 RPM", "400 RPM", "400 RPM", "600 RPM", "600 RPM", "600 RPM"],
    "Time": ["48 HRS", "72 HRS", "24 hrs", "48 hrs", "72 HRS", "24 hrs", "48 HRS", "72 HRS", "24 HRS"],
    "Sphericity Score": [83.387768, 86.566710, 81.530583, 68.746489, 85.306974, 72.359629, 62.821555, 79.010721, 81.360363]
}

df = pd.DataFrame(data)

# Clean columns
df["Ball Size"] = df["Ball Size"].str.extract("(\d+)").astype(float)
df["Speed"] = df["Speed"].str.extract("(\d+)").astype(float)
df["Time"] = df["Time"].str.extract("(\d+)").astype(float)

# Features and target
X = df[["Ball Size", "Speed", "Time"]]
y = df["Sphericity Score"]

# Train model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X, y)

# Create prediction grid for 1mm, 2mm, 3mm with speeds 400–1000 RPM and time 20–100 hrs

ball_sizes = [1, 2, 3]
speeds = list(range(400, 1001, 100))  # 400 to 1000 RPM in steps of 100
times = list(range(20, 101, 20))      # 20 to 100 HRS in steps of 20

predictions = []

for b in ball_sizes:
    for s in speeds:
        for t in times:
            pred = model.predict([[b, s, t]])[0]
            predictions.append([b, s, t, pred])

# Convert to DataFrame
pred_df = pd.DataFrame(predictions, columns=["Ball Size", "Speed", "Time", "Predicted Sphericity"])
print(pred_df)

# Optional: Save to CSV
pred_df.to_csv("predicted_sphericity.csv", index=False)

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import re
from mpl_toolkits.mplot3d import Axes3D

# Original data
data = {
    "Ball Size": ["10mm", "10mm", "10mm", "10mm", "10mm", "10mm", "5mm", "5mm", "5mm"],
    "Speed": ["600 RPM", "600 RPM", "600 RPM", "400 RPM", "400 RPM", "400 RPM", "600 RPM", "600 RPM", "600 RPM"],
    "Time": ["48 HRS", "72 HRS", "24 hrs", "48 hrs", "72 HRS", "24 hrs", "48 HRS", "72 HRS", "24 HRS"],
    "Sphericity Score": [83.387768, 86.566710, 81.530583, 68.746489, 85.306974, 72.359629, 62.821555, 79.010721, 81.360363]
}

df = pd.DataFrame(data)

# Clean and convert columns
df["Ball Size"] = df["Ball Size"].str.extract("(\d+)").astype(float)
df["Speed"] = df["Speed"].str.extract("(\d+)").astype(float)
df["Time"] = df["Time"].str.extract("(\d+)").astype(float)

# --- Correlation Matrix ---
corr = df.corr(numeric_only=True)
print("Correlation Matrix:\n", corr)

plt.figure(figsize=(8, 6))
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.title("Correlation Matrix")
plt.show()

# --- Pairplot (Scatterplot Matrix) ---
sns.pairplot(df)
plt.suptitle("Pairwise Plots", y=1.02)
plt.show()

# --- 3D Scatter Plot ---
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df["Ball Size"], df["Speed"], df["Sphericity Score"], c=df["Time"], cmap='viridis', s=100)
ax.set_xlabel("Ball Size (mm)")
ax.set_ylabel("Speed (RPM)")
ax.set_zlabel("Sphericity Score")
ax.set_title("3D Relationship Plot")
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Sample Data
data = {
    "Ball Size": ["10mm", "10mm", "10mm", "10mm", "10mm", "10mm", "5mm", "5mm", "5mm"],
    "Speed": ["600 RPM", "600 RPM", "600 RPM", "400 RPM", "400 RPM", "400 RPM", "600 RPM", "600 RPM", "600 RPM"],
    "Time": ["48 HRS", "72 HRS", "24 hrs", "48 hrs", "72 HRS", "24 hrs", "48 HRS", "72 HRS", "24 HRS"],
    "Sphericity Score": [83.387768, 86.566710, 81.530583, 68.746489, 85.306974, 72.359629, 62.821555, 79.010721, 81.360363]
}

df = pd.DataFrame(data)

# Convert Ball Size to numeric
df["Ball Size"] = df["Ball Size"].str.extract("(\d+)").astype(float)

# --- Scatter Plot ---
plt.figure(figsize=(4,4))
sns.scatterplot(data=df, x="Ball Size", y="Sphericity Score", hue="Speed", style="Time", s=100)
plt.title("Ball Size vs Sphericity Score")
plt.xlabel("Ball Size (mm)")
plt.ylabel("Sphericity Score")
plt.grid(True)
plt.show()

# --- Optional: Lineplot if you want trend by Ball Size ---
plt.figure(figsize=(4,2))
sns.lineplot(data=df, x="Ball Size", y="Sphericity Score", ci=None, marker="o")
plt.title("Trend of Ball Size vs Sphericity Score")
plt.xlabel("Ball Size (mm)")
plt.ylabel("Sphericity Score")
plt.grid(True)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from mpl_toolkits.mplot3d import Axes3D

# Load predicted data
df = pd.read_csv("/content/predicted_sphericity.csv")

# Convert units to numeric if necessary
df["Ball Size"] = df["Ball Size"].astype(float)
df["Speed"] = df["Speed"].astype(float)
df["Time"] = df["Time"].astype(float)
df["Sphericity Score"] = df["Predicted Sphericity"].astype(float)

# --- 1. 3D Scatter Plot ---
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df["Ball Size"], df["Speed"], df["Sphericity Score"], c=df["Time"], cmap='viridis', s=50)
ax.set_xlabel("Ball Size (mm)")
ax.set_ylabel("Speed (RPM)")
ax.set_zlabel("Sphericity Score")
ax.set_title("3D Scatter: Ball Size vs Speed vs Sphericity")
plt.show()

# --- 2. Correlation Heatmap ---
plt.figure(figsize=(8, 6))
sns.heatmap(df.corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Correlation Between Parameters")
plt.show()

# --- 3. Lineplot: Sphericity vs Time for each Ball Size ---
plt.figure(figsize=(10, 6))
sns.lineplot(data=df, x="Time", y="Sphericity Score", hue="Ball Size", palette="Set1")
plt.title("Sphericity Score vs Time by Ball Size")
plt.xlabel("Time (hrs)")
plt.ylabel("Sphericity Score")
plt.grid(True)
plt.show()

# --- 4. Lineplot: Sphericity vs Speed for each Ball Size ---
plt.figure(figsize=(10, 6))
sns.lineplot(data=df, x="Speed", y="Sphericity Score", hue="Ball Size", palette="Set2")
plt.title("Sphericity Score vs Speed by Ball Size")
plt.xlabel("Speed (RPM)")
plt.ylabel("Sphericity Score")
plt.grid(True)
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Load your predicted data
df = pd.read_csv("predicted_sphericity.csv")

# Convert Ball Size and Sphericity Score to float if not already
df["Ball Size"] = df["Ball Size"].astype(float)
df["Sphericity Score"] = df["Predicted Sphericity"].astype(float)

# --- 1. Scatter Plot ---
plt.figure(figsize=(8, 5))
sns.scatterplot(data=df, x="Ball Size", y="Sphericity Score", hue="Ball Size", palette="viridis", s=100)
plt.title("Ball Size vs Sphericity Score - Scatter Plot")
plt.grid(True)
plt.show()

# --- 2. Box Plot (optional: to see distribution) ---
plt.figure(figsize=(8, 5))
sns.boxplot(data=df, x="Ball Size", y="Sphericity Score", palette="coolwarm")
plt.title("Ball Size vs Sphericity Score - Box Plot")
plt.grid(True)
plt.show()

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import LabelEncoder
from itertools import product
import matplotlib.pyplot as plt

# Load existing data
data = pd.DataFrame({
    "Ball Size": ["10mm", "10mm", "10mm", "10mm", "10mm", "10mm", "5mm", "5mm", "5mm"],
    "Speed": ["600 RPM", "600 RPM", "600 RPM", "400 RPM", "400 RPM", "400 RPM", "600 RPM", "600 RPM", "600 RPM"],
    "Time": ["48 HRS", "72 HRS", "24 hrs", "48 hrs", "72 HRS", "24 hrs", "48 HRS", "72 HRS", "24 HRS"],
    "Sphericity Score": [83.387768, 86.566710, 81.530583, 68.746489, 85.306974, 72.359629, 62.821555, 79.010721, 81.360363]
})

# Clean and convert units
data["Ball Size"] = data["Ball Size"].str.replace("mm", "").astype(float)
data["Speed"] = data["Speed"].str.replace(" RPM", "").astype(int)
data["Time"] = data["Time"].str.replace(" HRS", "").str.replace(" hrs", "").astype(int)

# Features and target
X = data[["Ball Size", "Speed", "Time"]]
y = data["Sphericity Score"]

# Model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X, y)

# Generate prediction data (1mm, 2mm, 3mm), (400,600,800 RPM), (20 to 80 hrs by 10)
ball_sizes = [1, 2, 3]
speeds = [400, 600, 800]
times = list(range(20, 81, 10))

# Create all combinations
predict_data = pd.DataFrame(list(product(ball_sizes, speeds, times)), columns=["Ball Size", "Speed", "Time"])

# Predict
predict_data["Predicted Sphericity"] = model.predict(predict_data)

# Show predictions
print(predict_data)

# Optional: Save predictions
predict_data.to_csv("predicted_sphericity_scores.csv", index=False)

# Plot
plt.figure(figsize=(10, 6))
for ball_size in ball_sizes:
    subset = predict_data[predict_data["Ball Size"] == ball_size]
    for speed in speeds:
        plt.plot(subset[subset["Speed"] == speed]["Time"],
                 subset[subset["Speed"] == speed]["Predicted Sphericity"],
                 label=f"{ball_size}mm - {speed}RPM")

plt.xlabel("Time (hrs)")
plt.ylabel("Predicted Sphericity")
plt.title("Predicted Sphericity vs Time")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()



import os
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

def calculate_sphericity(image_path):
    # Load image in grayscale
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    plt.figure(figsize=(6,6))
    plt.imshow(image, cmap='gray')
    plt.title("Original Image")
    plt.axis('off')
    plt.show()

    # Apply Gaussian blur to reduce noise
    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    plt.figure(figsize=(6,6))
    plt.imshow(blurred, cmap='gray')
    plt.title("Blurred Image")
    plt.axis('off')
    plt.show()

    # Apply Otsu's thresholding
    _, thresh = cv2.threshold(blurred, 40, 255, cv2.THRESH_BINARY_INV)
    _, thresh = cv2.threshold(thresh, 10, 255, cv2.THRESH_BINARY_INV)
    plt.figure(figsize=(6,6))
    plt.imshow(thresh, cmap='gray')
    plt.title("Thresholded Image (THRESH_BINARY_INV)")
    plt.axis('off')
    plt.show()

    # Morphological Closing
    kernel = np.ones((3, 3), np.uint8)
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=5)
    plt.figure(figsize=(6,6))
    plt.imshow(closed, cmap='gray')
    plt.title("Closed Image")
    plt.axis('off')
    plt.show()

    # Canny Edge Detection
    edges = cv2.Canny(closed, 100, 200)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    plt.figure(figsize=(6,6))
    plt.imshow(edges, cmap='gray')
    plt.title("Edge Detection")
    plt.axis('off')
    plt.show()

    # Draw Contours
    contour_img = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)
    cv2.drawContours(contour_img, contours, -1, (0, 255, 0), 2)
    plt.figure(figsize=(8, 8))
    plt.imshow(contour_img)
    plt.title("Contours")
    plt.axis('off')
    plt.show()

    sphericity_scores = []
    size_weights = []

    for contour in contours:
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if area < 50 or perimeter == 0:
            continue

        circularity = (np.sqrt(area) * np.sqrt(np.pi)) / (perimeter / 2)
        print('circularity:', circularity)
        sphericity_score = min(100, max(0, circularity * 100))

        sphericity_scores.append(sphericity_score)
        size_weights.append(area)

    if sphericity_scores:
        weighted_sphericity = np.average(sphericity_scores, weights=size_weights)
        median_sphericity = np.median(sphericity_scores)
        maximum_sphericity = np.max(sphericity_scores)
        mode_sphericity = stats.mode(sphericity_scores, keepdims=True).mode[0]
    else:
        weighted_sphericity = 0
        median_sphericity = 0
        maximum_sphericity = 0
        mode_sphericity = 0

    print("Average:", weighted_sphericity)
    print("Median:", median_sphericity)
    print("Maximum:", maximum_sphericity)
    print("Mode:", mode_sphericity)

    return weighted_sphericity

# Folder containing all microstructure data
root_folder = "/content/sample_data/data"  # Change this path as needed

# List to store results
results = []

# Iterate through each condition folder
for condition_folder in os.listdir(root_folder):
    condition_path = os.path.join(root_folder, condition_folder)
    if not os.path.isdir(condition_path):
        continue

    parts = condition_folder.split(",")
    if len(parts) < 2:
        continue

    ball_size = parts[0].strip()
    speed = parts[1].strip()

    for image_file in os.listdir(condition_path):
        if not (image_file.endswith(".png") or image_file.endswith(".jpg") or image_file.endswith(".tif")):
            continue

        time = image_file.replace(".png", "").replace(".jpg", "").replace(".tif", "").strip()
        image_path = os.path.join(condition_path, image_file)
        sphericity = calculate_sphericity(image_path)
        results.append([ball_size, speed, time, sphericity])

# Convert results to DataFrame and save
df = pd.DataFrame(results, columns=["Ball Size", "Speed", "Time", "Sphericity Score"])
df.to_csv("sphericity_results.csv", index=False)
print(df)



import os
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

def calculate_sphericity(image_path):
    # Load image in grayscale
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    plt.figure(figsize=(6,6))
    plt.imshow(image, cmap='gray')
    plt.title("Original Image")
    plt.axis('off')
    plt.show()

    # Apply Gaussian blur to reduce noise
    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    plt.figure(figsize=(6,6))
    plt.imshow(blurred, cmap='gray')
    plt.title("Blurred Image")
    plt.axis('off')
    plt.show()

    # Apply Otsu's thresholding
    _, thresh = cv2.threshold(blurred, 40, 255, cv2.THRESH_BINARY_INV)
    _, thresh = cv2.threshold(thresh, 10, 255, cv2.THRESH_BINARY_INV)
    plt.figure(figsize=(6,6))
    plt.imshow(thresh, cmap='gray')
    plt.title("Thresholded Image (THRESH_BINARY_INV)")
    plt.axis('off')
    plt.show()

    # Morphological Closing
    kernel = np.ones((3, 3), np.uint8)
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=0)
    plt.figure(figsize=(6,6))
    plt.imshow(closed, cmap='gray')
    plt.title("Closed Image")
    plt.axis('off')
    plt.show()

    # Canny Edge Detection
    edges = cv2.Canny(closed, 100, 200)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    plt.figure(figsize=(6,6))
    plt.imshow(edges, cmap='gray')
    plt.title("Edge Detection")
    plt.axis('off')
    plt.show()

    # Draw Contours
    contour_img = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)
    cv2.drawContours(contour_img, contours, -1, (0, 255, 0), 2)
    plt.figure(figsize=(8, 8))
    plt.imshow(contour_img)
    plt.title("Contours")
    plt.axis('off')
    plt.show()

    sphericity_scores = []
    size_weights = []

    for contour in contours:
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)
        if area < 50 or perimeter == 0:
            continue

        circularity = (np.sqrt(area) * np.sqrt(np.pi)) / (perimeter / 2)
        print('circularity:', circularity)
        sphericity_score = min(100, max(0, circularity * 100))

        sphericity_scores.append(sphericity_score)
        size_weights.append(area)

    if sphericity_scores:
        weighted_sphericity = np.average(sphericity_scores, weights=size_weights)
        median_sphericity = np.median(sphericity_scores)
        maximum_sphericity = np.max(sphericity_scores)
        mode_sphericity = stats.mode(sphericity_scores, keepdims=True).mode[0]
    else:
        weighted_sphericity = 0
        median_sphericity = 0
        maximum_sphericity = 0
        mode_sphericity = 0

    print("Average:", weighted_sphericity)
    print("Median:", median_sphericity)
    print("Maximum:", maximum_sphericity)
    print("Mode:", mode_sphericity)

    return weighted_sphericity

print(calculate_sphericity("/content/Ti Atomised_13.tif"))

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Create DataFrame
data = {
    'Ball Size': [5, 5, 10, 10, 5, 10, 10, 10, 10],
    'Speed (RPM)': [400, 400, 600, 400, 400, 400, 400, 600, 600],
    'Time (HRS)': [24, 72, 72, 72, 48, 48, 24, 24, 48],
    'Sphericity Score': [83.387768, 86.56671, 81.530583, 68.746489, 85.306974,
                         72.359629, 62.821555, 79.010721, 81.360363]
}

df = pd.DataFrame(data)

# Compute correlation matrix
correlation_matrix = df.corr(numeric_only=True)

# Plot heatmap
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor

# Original dataset
data = {
    'Ball Size': [5, 5, 10, 10, 5, 10, 10, 10, 10],
    'Speed': [400, 400, 600, 400, 400, 400, 400, 600, 600],
    'Time': [24, 72, 72, 72, 48, 48, 24, 24, 48],
    'Sphericity Score': [83.387768, 86.56671, 81.530583, 68.746489, 85.306974,
                         72.359629, 62.821555, 79.010721, 81.360363]
}
df = pd.DataFrame(data)

# Features and target
X = df[["Ball Size", "Speed", "Time"]]
y = df["Sphericity Score"]

# Train the model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X, y)

# Generate prediction dataset
ball_sizes = [1, 2, 3]
speeds = np.arange(100, 1001, 100)
times = np.arange(10, 101, 10)

# Create combinations
prediction_data = pd.DataFrame([
    [b, s, t] for b in ball_sizes for s in speeds for t in times
], columns=["Ball Size", "Speed", "Time"])

# Predict sphericity
prediction_data["Predicted Sphericity"] = model.predict(prediction_data)

# Output first few rows
print(prediction_data.head(10))

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor

# Original dataset
data = {
    'Ball Size': [5, 5, 10, 10, 5, 10, 10, 10, 10],
    'Speed': [400, 400, 600, 400, 400, 400, 400, 600, 600],
    'Time': [24, 72, 72, 72, 48, 48, 24, 24, 48],
    'Sphericity Score': [83.387768, 86.56671, 81.530583, 68.746489, 85.306974,
                         72.359629, 62.821555, 79.010721, 81.360363]
}
df = pd.DataFrame(data)

# Features and target
X = df[["Ball Size", "Speed", "Time"]]
y = df["Sphericity Score"]

# Train the model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X, y)

# Generate prediction dataset
ball_sizes = [1, 2, 3]
speeds = np.arange(100, 1001, 100)
times = np.arange(10, 101, 10)

# Create combinations
prediction_data = pd.DataFrame([
    [b, s, t] for b in ball_sizes for s in speeds for t in times
], columns=["Ball Size", "Speed", "Time"])

# Predict sphericity
prediction_data["Predicted Sphericity"] = model.predict(prediction_data)

# Save to CSV
prediction_data.to_csv("predicted_sphericity_results.csv", index=False)

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import numpy as np

# Assuming `model`, `X`, and `y` are already defined
y_pred = model.predict(X)

mse = mean_squared_error(y, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y, y_pred)
r2 = r2_score(y, y_pred)

print("MSE:", mse)
print("RMSE:", rmse)
print("MAE:", mae)
print("R² Score:", r2)

